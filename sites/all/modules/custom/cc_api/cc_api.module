<?php
/**
 * @file
 * Main module file for the CC API module.
 * 
 * This module is aimed at providing a public
 * documenation page(s) for the implemented
 * Marketplace API.
 *
 * Also a set of tests specific to configured API.
 */

/**
 * Implements hook_help().
 */
function cc_api_help($path, $arg) {
  switch ($path) {
    // Main module help for the CC API module
    case 'admin/help#cc_api':
      return '<p>' . t('The CC API module provides more in-depth API documentation.') . '</p>';
  
  }
}

/**
 * Implements hook_menu().
 */
function cc_api_menu() {
  $path = variable_get('cc_api_doc_page_path', 'api');
  $items[$path] = array(
    'title' => variable_get('cc_api_doc_page_title', 'Marketplace API'), 
    'page callback' => 'cc_api_documentation_page', 
    'access arguments' => array('access content'), 
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/config/services/cc_api'] = array(
    'title' => 'Marketplace API', 
    'description' => 'Configure the marketplace API settings.',
    'page callback' => 'drupal_get_form', 
    'page arguments' => array('cc_api_admin_settings'), 
    'access arguments' => array('administer site configuration'), 
    'file' =>  'includes/cc_api.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}


/**
 * Implements hook_theme().
 */
 
/**
 * Main callback for API documentation page.
 */
function cc_api_documentation_page() {
  $api = array();
  
  // Let's get the API data.  We will assume that we only
  // want services resources that are in the format:
  // "mktplc_api_"
  $prefix = 'mktplc_api_';
  
  module_load_include('resource_build.inc', 'services');
  // Call _services_build_resources() directly instead of
  // services_get_resources to bypass caching.
  $resources = _services_build_resources();
  
  // Go through available endpoints.
  $endpoints = services_endpoint_load_all();
  foreach ($endpoints as $ep_id => $ep) {
    // Check prefix first
    if (strpos($ep_id, $prefix) !== 0) {
      continue;
    }
    
    // Start the data
    $api[$ep_id] = $ep;
    
    // Go through resources and add details
    $config_types = array('actions', 'relationships', 'operations');
    foreach ($ep->resources as $entity => $config) {
      foreach ($config as $config_type => $config_set) {
        if (is_array($config_set) && in_array($config_type, $config_types)) {
          foreach ($config_set as $k => $v) {
          
            // These don't match up one to one, so there
            // is some custom logic.
            if ($config_type == 'operations') {
              $api[$ep_id]->resources[$entity][$config_type][$k] += 
                $resources[$entity][$k];
            }
            else {
              $api[$ep_id]->resources[$entity][$config_type][$k] += 
                $resources[$entity][$config_type][$k];
            }
          }
        }
      }
    }
  }
  
  // Allow for alter
  drupal_alter('cc_api', $api);
  
  // Create output
  return cc_api_display_documentation($api);
}

/**
 * Implements hook_cc_api_alter().
 */
function cc_api_cc_api_alter(&$apis) {
  foreach ($apis as $api_id => $api) {
    // Add title and description
    $apis[$api_id]->title = t('Version 01');
    $apis[$api_id]->description = '<p>' . t('The first version of the Marketplace API is focused on providing basic mechanisms for data input and output.  It may be a bit rough around the edges.') . '</p>';
    $apis[$api_id]->base_url = url($api->path, array('absolute' => TRUE));
  }
  
  $method_map = array(
    'retrieve'         => 'GET',
    'update'           => 'PUT',
    'delete'           => 'DELETE',
    'index'            => 'GET',
    'create'           => 'POST',
    'actions'          => 'POST',
    'targeted actions' => 'POST',
    'relationships'    => 'GET',
  );
}

/**
 * Main display operation for documentation
 */
function cc_api_display_documentation($apis) {
  $output = '';
  
  // There could be multiple (versions) apis.
  foreach ($apis as $api_id => $api) {
    //dpm($api);
    
    $output .= '
      <h2 class="api-title">' . $api->title . '</h2>
      <div class="api-description">
        ' . $api->description . '
      </div>
      
      <h3>' . t('URLs') . '</h3>
      <div class="api-description-url">
        <p>' . t('This API is a RESTful API, where URLs will be formed like the following:') . '</p>
        <code>' . $api->base_url . '/:entity.:format?:key=:value</code>
        <p>' . t('For instance:') . '</p>
        <code>' . $api->base_url . '/node.json?page=3</code>
      </div>
      
      <h3>' . t('Authentication') . '</h3>
      <div class="api-description-auth">
        <p>' . t('…') . '</p>
      </div>
    ';
    
    // Formatters.  Assuming rest servers.
    // Note that the Server settings need to be saved
    // for these options to be in the endpoint
    // object.
    $output .= '
      <h3>' . t('Output Formaters') . '</h3>
      <div class="api-description-formatters">
        <p>' . t('The following are the output formatters that are available with the API.') . '</p>
        <ul>
    ';
    foreach ($api->server_settings['rest_server']['formatters'] as $f => $enabled) {
      $output .= '<li>' . check_plain($f) . '</li>';
    }
    $output .= '
        </ul>
      </div>
    ';
      
    // Parsers.  Assuming Rest server.
    $output .= '
      <h3>' . t('Input Parsers') . '</h3>
      <div class="api-description-parsers">
        <p>' . t('…') . '</p>
      </div>
    ';
      
    $output .= '
      <h3>' . t('Limitations') . '</h3>
      <div class="api-description-limitation">
        <p>' . t('…') . '</p>
      </div>
    ';
    
  }
  
  return $output;
}